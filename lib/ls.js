/*
 *
LispyScript - Javascript using tree syntax!
This is the compiler written in javascipt
 *
*/

var version = "1.5.0",
    banner = "// Generated by LispyScript v" + version + "\n",
    isWhitespace = /\s/,
    isFunction = /^function\b|^defn\b|^fn\b/,
    validName = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/,
    noReturn = /^def\b|^var\b|^set\b|^set!\b|^throw\b/,
    isHomoiconicExpr = /^#args-if\b|^#args-shift\b|^#args-second\b/,
    noSemiColon = false,
    indentSize = 2,
    indent = -indentSize,
    macros = {},
    errors = [],
    include_dirs = [__dirname + "/../includes", "includes"],
    fs,
    path,
    SourceNode = require('source-map').SourceNode;

//////////////////////////////////////////////////////////////////////////////
//
errors[0] = "Syntax Error";
errors[1] = "Empty statement";
errors[2] = "Invalid characters in function name";
errors[3] = "End of File encountered, unterminated string";
errors[4] = "Closing square bracket, without an opening square bracket";
errors[5] = "End of File encountered, unterminated array";
errors[6] = "Closing curly brace, without an opening curly brace";
errors[7] = "End of File encountered, unterminated javascript object '}'";
errors[8] = "End of File encountered, unterminated parenthesis";
errors[9] = "Invalid character in var name";
errors[10] = "Extra chars at end of file. Maybe an extra ')'.";
errors[11] = "Cannot Open include File";
errors[12] = "Invalid no of arguments to ";
errors[13] = "Invalid Argument type to ";
errors[14] = "End of File encountered, unterminated regular expression";

//////////////////////////////////////////////////////////////////////////////
//
if (typeof window === "undefined") {
  path = require('path');
  fs = require('fs');
}

//////////////////////////////////////////////////////////////////////////////
//
if (!String.prototype.repeat) {
  String.prototype.repeat = function(num) {
    return new Array(num + 1).join(this);
  };
}

//////////////////////////////////////////////////////////////////////////////
//
function assert(cond, msg) {
  if (! cond) { throw new Error(msg); }
}

//////////////////////////////////////////////////////////////////////////////
//
function whatis(obj) {
  return Object.prototype.toString.call(obj);
}

//////////////////////////////////////////////////////////////////////////////
//
function isobject(obj) {
  return whatis(obj) === "[object Object]";
}

//////////////////////////////////////////////////////////////////////////////
//
function isstr(obj) {
  return whatis(obj) === "[object String]";
}

/*
Object.prototype.toString.call(new Date()); // [object Date]
Object.prototype.toString.call(1); // [object Number]
Object.prototype.toString.call(function () {}); // [object Function]
Object.prototype.toString.call(/test/i); // [object RegExp]
Object.prototype.toString.call(true); // [object Boolean]
Object.prototype.toString.call(null); // [object Null]
Object.prototype.toString.call(); // [object Undefined]
*/
//////////////////////////////////////////////////////////////////////////////
//
function isnode(obj) {
  return isobject(obj) && obj["$$$isSourceNode$$$"] === true;
}

//////////////////////////////////////////////////////////////////////////////
//
function handleError(no, line, filename, extra) {
  throw new Error(errors[no] +
                  ((extra) ? " - " + extra : "") +
                  ((line) ? "\nLine no " + line : "") +
                  ((filename) ? "\nFile " + filename : ""));
}

//////////////////////////////////////////////////////////////////////////////
//
function synError(c,arr) {
  return handleError(c, arr._line, arr._filename);
}

//////////////////////////////////////////////////////////////////////////////
//
function assertArgs(arr, cnt, err) {
  if (arr.length !== cnt) { synError(err, arr); }
}

//////////////////////////////////////////////////////////////////////////////
//
function assertNode(n) {
  if (! isnode(n)) {
    console.log("expecting node, got: " + whatis(n));
    if (isform(n)) {
      console.log("expecting node, line: " + n._line);
    }
    assert(false, "source node expected");
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function inst(obj) { return typeof obj; }

//////////////////////////////////////////////////////////////////////////////
//
function isarray(a) { return Array.isArray(a); }
function isform(a) { return Array.isArray(a); }

//////////////////////////////////////////////////////////////////////////////
//
function pad(z) { return " ".repeat(z); }

//////////////////////////////////////////////////////////////////////////////
//
function snode(ln,col,fn,chunk,name) {
  if (arguments.length > 0) {
    return name ? new SourceNode(ln, col, fn, chunk, name)
                : new SourceNode(ln, col, fn, chunk);
  } else {
    return new SourceNode();
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function snodeChunk(chunk) {
  return snode(null,null,null,chunk);
}

//////////////////////////////////////////////////////////////////////////////
//
function toAST(codeStr, filename) {
  codeStr = "(" + codeStr + ")";
  let length = codeStr.length,
    pos = 1,
    lineno = 1,
    colno = 1,
    tokenBeginCol = 1,
    handleToken = function(tree,token) {
      if (token) {
        if (":else" == token) { token="true";}
        if ("nil" == token) { token="null";}
        tree.push(snode(lineno, tokenBeginCol - 1, filename, token,token));
      }
      return "";
    },
    parseError=function(c,tree) {
      synError(c, tree);
    },
    tokenize = function() {
      let tree = [],
          token = "",
          isString = false,
          isSingleString = false,
          isJSArray = 0,
          isJSObject = 0,
          isListComplete = false,
          isComment = false,
          isRegex = false,
          isEscape = false;

      tree._filename = filename;
      tree._line = lineno;
      while (pos < length) {
        let c = codeStr.charAt(pos);
        pos++; colno++;
        if (c === "\n") {
          lineno++; colno = 1;
          if (isComment) { isComment = false; }
        }
        if (isComment) { continue; }
        if (isEscape) {
          isEscape = false; token += c; continue; }
        // strings
        if (c === '"') {
          isString = !isString; token += c; continue; }
        if (isString) {
          if (c === "\n") {
            token += "\\n";
          }
          else {
            if (c === "\\") { isEscape = true; }
            token += c;
          }
          continue;
        }
        if (c === "'") {
          isSingleString = !isSingleString;
          token += c;
          continue;
        }
        if (isSingleString) {
          token += c;
          continue;
        }
        // data types
        if (c === "[") {
          isJSArray++;
          token += c;
          continue;
        }
        if (c === "]") {
          if (isJSArray === 0) {
            parseError(4, tree);
          }
          isJSArray--;
          token += c;
          continue;
        }
        if (isJSArray) {
          token += c;
          continue;
        }
        if (c == "{") {
          isJSObject++;
          token += c;
          continue;
        }
        if (c == '}') {
          if (isJSObject === 0) {
            parseError(6, tree);
          }
          isJSObject--;
          token += c;
          continue;
        }
        if (isJSObject) {
          token += c;
          continue;
        }
        if (c === ";") {
          isComment = true;
          continue;
        }
        // regex
        // regex in function position with first char " " is a prob. Use \s instead.
        if (c === "/"&&
            !(tree.length === 0 &&
              token.length === 0 &&
              isWhitespace.test(codeStr.charAt(pos)))) {
          isRegex = !isRegex;
          token += c;
          continue;
        }
        if (isRegex) {
          if (c === "\\") {
            isEscape = true;
          }
          token += c;
          continue;
        }
        if (c === "(") {
          token=handleToken(tree,token); // catch e.g. "blah("
          tokenBeginCol = colno;
          tree.push(tokenize());
          continue;
        }
        if (c === ")") {
          isListComplete = true;
          token=handleToken(tree,token);
          tokenBeginCol = colno;
          break;
        }
        if (isWhitespace.test(c)) {
          if (c === "\n") { lineno--; }
          token=handleToken(tree,token);
          if (c === "\n") { lineno++; }
          tokenBeginCol = colno;
          continue;
        }
        token += c;
      }
      if (isString || isSingleString) { parseError(3, tree);}
      if (isRegex) { parseError(14, tree); }
      if (isJSArray > 0) { parseError(5, tree); }
      if (isJSObject > 0) { parseError(7, tree); }
      if (!isListComplete) { parseError(8, tree); }
      return tree;
    },
    ret = tokenize();
    return (pos < length) ? handleError(10) : ret;
}

//////////////////////////////////////////////////////////////////////////////
// [expr,...] -> SourceNode
function evalAST(astTree) {
  let ret = snode(),
      len = astTree.length;

  indent += indentSize;
  indentstr = pad(indent);

  astTree.forEach(function(expr, i, tree) {
    let name="", tmp = null, r = "";
    if (isform(expr)) {
      if (isnode(expr[0])) {
        name = expr[0].name;
      }
      tmp = evalForm(expr) ;
      if (name === "include") {
        ret.add(tmp);
        tmp=null;
      }
    } else {
      tmp = expr;
    }
    if (i === len - 1 &&
        indent &&
        !noReturn.test(name)) {
      r = "return ";
    }
    if (tmp) {
      ret.add([indentstr + r,
               tmp, noSemiColon ? "\n" : ";\n"]);
      noSemiColon = false;
    }
  });

  indent -= indentSize;
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function evalForm(form) {

  if (!form || !form[0]) { return null; }

  let cmd = "";

  if (isnode(form[0])) {
    cmd=form[0].name;
  }

  if (macros[cmd]) {
    let m = evalMacro(form);
    return isform(m) ? evalForm(m) : m;
  }

  if (isstr(cmd)) {
    if (cmd.charAt(0) === ".") {
      let ret = snode();
      ret.add(isform(form[1])
              ? evalForm(form[1]) : form[1]);
      ret.prepend("(");
      ret.add([")", form[0]]);
      return ret;
    }
    switch (cmd) {
      case "var": return sf_var(form, "let");
      case "def": return sf_var(form, "var");
      case "new": return sf_new(form);
      case "throw": return sf_throw(form);
      case "set!": return sf_set(form);
      case "get": return sf_get(form);
      case "defn": return sf_func(form);
      case "function":
      case "fn": return sf_anonFunc(form);
      case "try": return sf_try(form);
      case "if": return sf_if(form);
      case "str": return sf_str(form);
      case "array": return sf_array(form);
      case "object": return sf_object(form);
      case "include": return sf_include(form);
      case "javascript": return sf_jscode(form);
      case "defmacro":
      case "macro": return sf_macro(form);
      case "+":
      case "-":
      case "*":
      case "/":
      case "%":
        return handleArithOperator(form);
      break;
      case "||":
      case "&&":
        return handleLogicalOperator(form);
      break;
      case "!=":
      case "=":
      case ">":
      case ">=":
      case "<":
      case "<=":
        return handleCompOperator(form);
      break;
      case "!":
        return sf_not(form);
      break;
    }
  }

  evalSexp(form);

  let fName = form[0];
  if (!fName) {
    handleError(1, form._line);
  }

  if (isFunction.test(fName)) {
    fName = snodeChunk(["(", fName, ")"]);
  }

  return snodeChunk([fName, "(",
                     snodeChunk(form.slice(1)).join(","), ")"]);
}

//////////////////////////////////////////////////////////////////////////////
//
function evalSexp(sexp) {
  sexp.forEach(function(part, i, t) {
    if (isform(part)) { t[i] = evalForm(part); }
  });
}

//////////////////////////////////////////////////////////////////////////////
//
function evalMacro(tree) {
  let command = tree[0].name,
      template = macros[command]["template"],
      code = macros[command]["code"],
      replacements = {};

  for (var i = 0; i < template.length; ++i) {
    if (template[i].name === "rest...") {
      replacements["~rest..."] = tree.slice(i + 1);
    } else {
      if (tree.length === i + 1) {
        // we are here if any macro arg is not set
        handleError(12, tree._line, tree._filename, command);
      }
      replacements["~" + template[i].name] = tree[i + 1];
    }
  }

  let replaceCode = function(source) {
    // handle homoiconic expressions in macro
    let ret= [],
        expr_name = source[0] ? source[0].name : "";

    ret._filename = tree._filename;
    ret._line = tree._line;

    if (isHomoiconicExpr.test(expr_name)) {
      let replarray = replacements["~" + source[1].name];
      if (expr_name === "#args-shift") {
        if (!isarray(replarray)) {
          handleError(13, tree._line, tree._filename, command);
        }
        let argshift = replarray.shift();
        if (inst(argshift) === "undefined") {
          handleError(12, tree._line, tree._filename, command);
        }
        return argshift;
      }
      if (expr_name === "#args-second") {
        if (!isarray(replarray)) {
          handleError(13, tree._line, tree._filename, command);
        }
        let argsecond = replarray.splice(1, 1)[0];
        if (inst(argsecond) === "undefined") {
          handleError(12, tree._line, tree._filename, command);
        }
        return argsecond;
      }
      if (expr_name === "#args-if") {
        if (!isarray(replarray)) {
          handleError(13, tree._line, tree._filename, command);
        }
        if (replarray.length) {
          return replaceCode(source[2]);
        } else if (source[3]) {
          return replaceCode(source[3]);
        } else {
          return;
        }
      }
    }
    for (var i = 0; i < source.length; ++i) {
      if (isarray(source[i])) {
        let replcode = replaceCode(source[i]);
        if (inst(replcode) !== "undefined") {
          ret.push(replcode);
        }
      } else {
        let token = source[i],
            tokenbak = token,
            isATSign = false;
        if (token.name.indexOf("@") >= 0) {
          isATSign = true;
          tokenbak = snode(token.line,
                           token.column,
                           token.source,
                           token.name.replace("@", ""),
                           token.name.replace("@", ""));
        }
        if (replacements[tokenbak.name]) {
          let repl = replacements[tokenbak.name];
          if (isATSign || tokenbak.name === "~rest...") {
            for (var j = 0; j < repl.length; ++j) {
              ret.push(repl[j]);
            }
          } else {
            ret.push(repl);
          }
        } else {
          ret.push(token);
        }
      }
    }
    return ret;
  }

  return replaceCode(code);
}

//////////////////////////////////////////////////////////////////////////////
//
function handleCompOperator(arr) {
  if (arr.length < 3) { handleError(0, arr._line); }
  evalSexp(arr);

  // dont use === as arr[0] is a source node
  if (arr[0] == "!=") { arr[0] = "!=="; }
  if (arr[0] == "=") { arr[0] = "==="; }

  let op = arr.shift(),
      ret = snode();

  for (var i = 0; i < arr.length - 1; ++i) {
    ret.add (snode(null, null, null, [arr[i], " ", op, " ", arr[i + 1]]));
  }

  ret.join(" && ");
  ret.prepend("(");
  ret.add(")");
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function handleArithOperator(arr) {
  if (arr.length < 3) { handleError(0, arr._line); }
  evalSexp(arr);

  let op = snode(),
      ret= snode();

  op.add([" ", arr.shift(), " "]);
  ret.add(arr);
  ret.join(op);
  ret.prepend("(");
  ret.add(")");
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function handleLogicalOperator(arr) {
  return handleArithOperator(arr);
}

//////////////////////////////////////////////////////////////////////////////
//special forms
//////////////////////////////////////////////////////////////////////////////
function sf_var(form, cmd) {

  if (form.length < 3 ||
      0 === (form.length % 2)) {
    synError(0, form); }

  if (form.length > 3) {
    indent += indentSize; }

  evalSexp(form);
  let ret = snode();
  for (var i = 1; i < form.length; i = i + 2) {
    if (i > 1) {
      ret.add(",\n" + pad(indent));
    }
    if (!validName.test(form[i])) { synError(9, form); }
    ret.add([form[i], " = ", form[i + 1]]);
  }
  ret.prepend(" ");
  ret.prepend(cmd);
  if (form.length > 3) {
    indent -= indentSize; }
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_new(form) {
  if (form.length < 2) { synError(0, form); }
  let ret = snode();
  ret.add(evalForm(form.slice(1)));
  ret.prepend("new ");
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_throw(form) {
  assertArgs(form, 2, 0);
  let ret = snode();
  ret.add(isform(form[1]) ? evalForm(form[1]) : form[1]);
  //ret.prepend("(function(){ throw ");
  //ret.add(";})()");
  ret.prepend("throw ");
  ret.add(";");
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function xxxset(form) {
  if (form.length < 3 || form.length > 4) { synError(0, form); }
  if (form.length === 4) {
    form[1] = (isform(form[2]) ? evalForm(form[2]) : form[2]) +
             "[" + form[1] + "]";
    form[2] = form[3];
  }
  return snodeChunk([form[1],
                     " = ",
                     isform(form[2]) ? evalForm(form[2]) : form[2]]);
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_set(form) {
  if (form.length < 3 || form.length > 4) { synError(0, form); }
  if (form.length === 4) {
    if (isform(form[1])) { form[1]= evalForm(form[1]); }
    if (isform(form[2])) { form[2]= evalForm(form[2]); }
    form[1] = form[1] + "[" + form[2] + "]";
    form[2] = form[3];
  }
  return snodeChunk([form[1],
                     " = ",
                     isform(form[2]) ? evalForm(form[2]) : form[2]]);
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_anonFunc(arr) {
  if (arr.length < 2) { synError(0, arr); }

  if (! isform(arr[1])) {
    handleError(0, arr._line);
  }

  let fArgs = arr[1],
      fBody = arr.slice(2),
      ret = snodeChunk(fArgs);
  ret.join(",");
  ret.prepend("function (");
  ret.add([") {\n",evalAST(fBody), pad(indent), "}"]);
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_func(arr) {

  if (arr.length < 2) { synError(0, arr); }

  let ret, fName, fArgs, fBody;

  if (!isform(arr[1]) && isform(arr[2])) {
    fName = arr[1];
    fArgs = arr[2];
    fBody = arr.slice(3);
  }
  else { handleError(0, arr._line); }

  ret = snodeChunk(fArgs);
  ret.join(",");
  ret.prepend("function " + fName.name + "(");
  ret.add([") {\n",evalAST(fBody), pad(indent), "}"]);
  noSemiColon = true;
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_try(arr) {

  if (arr.length < 3) { synError(0, arr); }

  let ind = pad(indent), c = arr.pop();

  return snodeChunk(["(function() {\n" + ind + "try {\n",
                     evalAST(arr.slice(1)),
                     "\n" + ind + "} catch (e) {\n" + ind + "return (",
                     (isform(c) ? evalForm(c) : c),
                     ")(e);\n" + ind + "}\n" + ind + "})()"]);
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_if(arr) {
  if (arr.length < 3 || arr.length > 4)  { synError(0, arr); }
  indent += indentSize;
  evalSexp(arr);
  try {
    return snodeChunk(["(",
                       arr[1],
                       " ?\n" + pad(indent),
                       arr[2],
                       " :\n" + pad(indent),
                       (arr[3] || "undefined"), ")"]);
  } finally {
    indent -= indentSize;
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function XXget(arr) {
  assertArgs(arr, 3, 0);
  evalSexp(arr);
  return snode(null, null, null, [arr[2], "[", arr[1], "]"]);
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_get(arr) {
  assertArgs(arr, 3, 0);
  evalSexp(arr);
  return snodeChunk([arr[1], "[", arr[2], "]"]);
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_str(arr) {
  if (arr.length < 2) { synError(0, arr); }
  evalSexp(arr);
  let ret = snode();
  ret.add(arr.slice(1));
  ret.join(",");
  ret.prepend("[");
  ret.add("].join('')");
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_array(arr) {
  let ret = snode(),
      p= pad(indent),
      epilog="\n" + p + "]";

  if (arr.length === 1) {
    ret.add("[]");
    return ret;
  }

  try {
    indent += indentSize;
    evalSexp(arr);
    p= pad(indent);
    ret.add("[\n" + p);
    for (var i = 1; i < arr.length; ++i) {
      if (i > 1) {
        ret.add(",\n" + p);
      }
      ret.add(arr[i]);
    }
    ret.add(epilog);
    return ret;
  } finally {
    indent -= indentSize;
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_object(arr) {
  let ret = snode(),
      p= pad(indent),
      epilog= "\n" + p + "}";

  if (arr.length === 1) {
    ret.add("{}");
    return ret;
  }

  try {
    indent += indentSize;
    evalSexp(arr);
    p=pad(indent);
    ret.add("{\n" + p);
    for (var i = 1; i < arr.length; i = i + 2) {
      if (i > 1) {
        ret.add(",\n" + p); }
      ret.add([arr[i], ": ", arr[i + 1]]);
    }
    ret.add(epilog);
    return ret;
  } finally {
    indent -= indentSize;
  }
}

//////////////////////////////////////////////////////////////////////////////
//
var includeFile = (function () {
  let icache = [];
  return function(fname) {
    if (icache.indexOf(fname) !== -1) { return ""; }
    icache.push(fname);
    return evalAST(toAST(fs.readFileSync(fname), fname));
  };
})();

//////////////////////////////////////////////////////////////////////////////
//
function sf_include(arr) {

  assertArgs(arr, 2, 0);

  let found=false,
      fname = arr[1].name;

  if (isstr(fname)) {
    fname = fname.replace(/["']/g, ""); }
  indent -= indentSize;

  include_dirs.
    concat([path.dirname(arr._filename)]).
    forEach(function(pfx) {
      if (found) { return; }
      try {
        fname = fs.realpathSync(pfx + '/' +fname);
        found = true;
      } catch (err) {}
    });

  if (!found) { synError(11, arr); }

  try {
    return includeFile(fname);
  } finally {
    indent += indentSize;
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_jscode(arr) {
  assertArgs(arr, 2, 0);
  noSemiColon = true;
  arr[1].replaceRight(/"/g, "");
  return arr[1];
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_macro(arr) {
  assertArgs(arr, 4, 0);
  macros[arr[1].name] = {template: arr[2],
                         code:     arr[3]};
  return "";
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_not(arr) {
  assertArgs(arr, 2, 0);
  evalSexp(arr);
  return "(!" + arr[1] + ")";
}

//////////////////////////////////////////////////////////////////////////////
//
function dbg(obj, hint) {
  if (isarray(obj)) {
    hint= hint || "block";
    console.log("<"+hint+">");
    for (var i=0; i < obj.length; ++i) {
      dbg(obj[i]);
    }
    console.log("</"+hint+">");
  } else if (isnode(obj)) {
    console.log("<node>");
    console.log(obj);
    dbg(obj.children,"subs");
    console.log("</node>");
  } else {
    console.log(obj);
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function dbgAST(codeStr, fname) {
  let tree= toAST(codeStr, fname);
  dbg(tree, "tree");
}

//////////////////////////////////////////////////////////////////////////////
//
function compileCode(codeStr, fname, withSrcMap, a_include_dirs) {

  if (a_include_dirs) { include_dirs = a_include_dirs; }
  indent = -indentSize;

  let outNode = evalAST(toAST(codeStr, fname));
  outNode.prepend(banner);

  if (withSrcMap) {
    let outFile = path.basename(fname, ".ls") + ".js",
        srcMap = outFile + ".map",
        output = outNode.toStringWithSourceMap( { file: outFile });

    fs.writeFileSync(srcMap, output.map);
    return output.code +
           "\n//# sourceMappingURL=" +
           path.relative(path.dirname(fname), srcMap);
  } else {
    return outNode.toString();
  }
}

//////////////////////////////////////////////////////////////////////////////
//
exports.transpileWithSrcMap=function(code,file,incDirs) {
  return compileCode(code,file,true,incDirs);
};
exports.transpile=function(code,file,incDirs) {
  return compileCode(code,file,false,incDirs);
};
exports.version = version;
exports.dbgAST=dbgAST;
exports.parseWithSourceMap = function(codeStr, fname) {
  let outNode = evalAST(toAST(codeStr, fname));
  outNode.prepend(banner);
  return outNode.toStringWithSourceMap();
};

//////////////////////////////////////////////////////////////////////////////
//EOF



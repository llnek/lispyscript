/*
 *
LispyScript - Javascript using tree syntax!
This is the compiler written in javascipt
 *
*/

var version = "1.5.0",
    banner = "// Generated by LispyScript v" + version + "\n",
    isWhitespace = /\s/,
    isFunction = /^function\b/,
    isFn = /^fn\b/,
    validName = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/,
    noReturn = /^var\b|^set\b|^set!\b|^throw\b/,
    isHomoiconicExpr = /^#args-if\b|^#args-shift\b|^#args-second\b/,
    noSemiColon = false,
    indentSize = 2,
    indent = -indentSize,
    keywords = {},
    macros = {},
    errors = [],
    include_dirs = [__dirname + "/../includes", "includes"],
    fs,
    path,
    SourceNode = require('source-map').SourceNode;

//////////////////////////////////////////////////////////////////////////////
//
errors[0] = "Syntax Error";
errors[1] = "Empty statement";
errors[2] = "Invalid characters in function name";
errors[3] = "End of File encountered, unterminated string";
errors[4] = "Closing square bracket, without an opening square bracket";
errors[5] = "End of File encountered, unterminated array";
errors[6] = "Closing curly brace, without an opening curly brace";
errors[7] = "End of File encountered, unterminated javascript object '}'";
errors[8] = "End of File encountered, unterminated parenthesis";
errors[9] = "Invalid character in var name";
errors[10] = "Extra chars at end of file. Maybe an extra ')'.";
errors[11] = "Cannot Open include File";
errors[12] = "Invalid no of arguments to ";
errors[13] = "Invalid Argument type to ";
errors[14] = "End of File encountered, unterminated regular expression";

//////////////////////////////////////////////////////////////////////////////
//
if (typeof window === "undefined") {
  path = require('path');
  fs = require('fs');
}

//////////////////////////////////////////////////////////////////////////////
//
if (!String.prototype.repeat) {
  String.prototype.repeat = function(num) {
    return new Array(num + 1).join(this);
  };
}

//////////////////////////////////////////////////////////////////////////////
//
function assert(cond, msg) {
  if (! cond) { throw new Error(msg); }
}

//////////////////////////////////////////////////////////////////////////////
//
function isobject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}

//////////////////////////////////////////////////////////////////////////////
//
function isstr(obj) {
  return Object.prototype.toString.call(obj) === "[object String]";
}

/*
Object.prototype.toString.call(new Date()); // [object Date]
Object.prototype.toString.call(1); // [object Number]
Object.prototype.toString.call(function () {}); // [object Function]
Object.prototype.toString.call(/test/i); // [object RegExp]
Object.prototype.toString.call(true); // [object Boolean]
Object.prototype.toString.call(null); // [object Null]
Object.prototype.toString.call(); // [object Undefined]
*/
//////////////////////////////////////////////////////////////////////////////
//
function isnode(obj) {
  return isobject(obj) && obj["$$$isSourceNode$$$"] === true;
}

//////////////////////////////////////////////////////////////////////////////
//
function handleError(no, line, filename, extra) {
  throw new Error(errors[no] +
                  ((extra) ? " - " + extra : "") +
                  ((line) ? "\nLine no " + line : "") +
                  ((filename) ? "\nFile " + filename : ""));
}

//////////////////////////////////////////////////////////////////////////////
//
function synError(c,arr) {
  return handleError(c, arr._line, arr._filename);
}

//////////////////////////////////////////////////////////////////////////////
//
function assertArgs(arr, cnt, err) {
  if (arr.length !== cnt) { synError(err, arr); }
}

//////////////////////////////////////////////////////////////////////////////
//
function inst(obj) { return typeof obj; }

//////////////////////////////////////////////////////////////////////////////
//
function isarray(a) { return Array.isArray(a); }
function isform(a) { return Array.isArray(a); }

//////////////////////////////////////////////////////////////////////////////
//
function pad(z) { return " ".repeat(z); }

//////////////////////////////////////////////////////////////////////////////
//
function snode(ln,col,fn,chunk,name) {
  if (arguments.length > 0) {
    return name ? new SourceNode(ln, col, fn, chunk, name)
                : new SourceNode(ln, col, fn, chunk);
  } else {
    return new SourceNode();
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function snodeChunk(chunk) {
  return snode(null,null,null,chunk);
}

//////////////////////////////////////////////////////////////////////////////
//
function toAST(codeStr, filename) {
  codeStr = "(" + codeStr + ")";
  let length = codeStr.length,
    pos = 1,
    lineno = 1,
    colno = 1,
    tokenBeginCol = 1,
    handleToken = function(tree,token) {
      if (token) {
        if (":else" == token) { token="true";}
        if ("nil" == token) { token="null";}
        tree.push(snode(lineno, tokenBeginCol - 1, filename, token,token));
      }
      return "";
    },
    parseError=function(c,tree) {
      synError(c, tree);
    },
    tokenize = function() {
      let tree = [],
          token = "",
          isString = false,
          isSingleString = false,
          isJSArray = 0,
          isJSObject = 0,
          isListComplete = false,
          isComment = false,
          isRegex = false,
          isEscape = false;

      tree._filename = filename;
      tree._line = lineno;
      while (pos < length) {
        let c = codeStr.charAt(pos);
        pos++; colno++;
        if (c === "\n") {
          lineno++; colno = 1;
          if (isComment) { isComment = false; }
        }
        if (isComment) { continue; }
        if (isEscape) {
          isEscape = false; token += c; continue; }
        // strings
        if (c === '"') {
          isString = !isString; token += c; continue; }
        if (isString) {
          if (c === "\n") {
            token += "\\n";
          }
          else {
            if (c === "\\") { isEscape = true; }
            token += c;
          }
          continue;
        }
        if (c === "'") {
          isSingleString = !isSingleString;
          token += c;
          continue;
        }
        if (isSingleString) {
          token += c;
          continue;
        }
        // data types
        if (c === "[") {
          isJSArray++;
          token += c;
          continue;
        }
        if (c === "]") {
          if (isJSArray === 0) {
            parseError(4, tree);
          }
          isJSArray--;
          token += c;
          continue;
        }
        if (isJSArray) {
          token += c;
          continue;
        }
        if (c == "{") {
          isJSObject++;
          token += c;
          continue;
        }
        if (c == '}') {
          if (isJSObject === 0) {
            parseError(6, tree);
          }
          isJSObject--;
          token += c;
          continue;
        }
        if (isJSObject) {
          token += c;
          continue;
        }
        if (c === ";") {
          isComment = true;
          continue;
        }
        // regex
        // regex in function position with first char " " is a prob. Use \s instead.
        if (c === "/"&&
            !(tree.length === 0 &&
              token.length === 0 &&
              isWhitespace.test(codeStr.charAt(pos)))) {
          isRegex = !isRegex;
          token += c;
          continue;
        }
        if (isRegex) {
          if (c === "\\") {
            isEscape = true;
          }
          token += c;
          continue;
        }
        if (c === "(") {
          token=handleToken(tree,token); // catch e.g. "blah("
          tokenBeginCol = colno;
          tree.push(tokenize());
          continue;
        }
        if (c === ")") {
          isListComplete = true;
          token=handleToken(tree,token);
          tokenBeginCol = colno;
          break;
        }
        if (isWhitespace.test(c)) {
          if (c === "\n") { lineno--; }
          token=handleToken(tree,token);
          if (c === "\n") { lineno++; }
          tokenBeginCol = colno;
          continue;
        }
        token += c;
      }
      if (isString || isSingleString) { parseError(3, tree);}
      if (isRegex) { parseError(14, tree); }
      if (isJSArray > 0) { parseError(5, tree); }
      if (isJSObject > 0) { parseError(7, tree); }
      if (!isListComplete) { parseError(8, tree); }
      return tree;
    },
    ret = tokenize();
    return (pos < length) ? handleError(10) : ret;
}

//////////////////////////////////////////////////////////////////////////////
// [expr,...] -> SourceNode
function evalAST(astTree) {
  let ret = snode(),
      len = astTree.length;

  indent += indentSize;
  indentstr = pad(indent);

  astTree.forEach(function(expr, i, tree) {
    let name="", tmp = null, r = "";
    if (isform(expr)) {
      assert(isnode(expr[0]),
             "source node expected");
      name = expr[0].name;
      tmp = evalForm(expr) ;
      if (name === "include") {
        ret.add(tmp);
        tmp=null;
      }
    } else {
      assert(isnode(expr),
             "source node expected");
      tmp = expr;
    }
    if (i === len - 1 &&
        indent &&
        !noReturn.test(name)) {
      r = "return ";
    }
    if (tmp) {
      ret.add([indentstr + r,
               tmp, noSemiColon ? "\n" : ";\n"]);
      noSemiColon = false;
    }
  });

  indent -= indentSize;
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function evalForm(form) {

  if (!form || !form[0]) { return null; }

  assert(isnode(form[0]),
         "source node expected");

  let cmd = form[0].name;

  if (macros[cmd]) {
    let m = evalMacro(form);
    return isform(m) ? evalForm(m) : m;
  }

  if (isstr(cmd)) {

    if (keywords[cmd]) {
      return keywords[cmd](form);
    }

    if (cmd.charAt(0) === ".") {
      let ret = snode();
      ret.add(isform(form[1])
              ? evalForm(form[1]) : form[1]);
      ret.prepend("(");
      ret.add([")", form[0]]);
      return ret;
    }
  }

  evalSexp(form);

  let fName = form[0];

  if (!fName) {
    handleError(1, form._line);
  }

  if (isFunction.test(fName) || isFn.test(fName)) {
    fName = snodeChunk(["(", fName, ")"]);
  }

  return snodeChunk([fName, "(",
                     snodeChunk(form.slice(1)).join(","), ")"]);
}

//////////////////////////////////////////////////////////////////////////////
//
function evalSexp(sexp) {
  sexp.forEach(function(part, i, t) {
    if (isform(part)) { t[i] = evalForm(part); }
  });
}

//////////////////////////////////////////////////////////////////////////////
//
function evalMacro(tree) {
  let command = tree[0].name,
      template = macros[command]["template"],
      code = macros[command]["code"],
      replacements = {};

  for (var i = 0; i < template.length; ++i) {
    if (template[i].name === "rest...") {
      replacements["~rest..."] = tree.slice(i + 1);
    } else {
      if (tree.length === i + 1) {
        // we are here if any macro arg is not set
        handleError(12, tree._line, tree._filename, command);
      }
      replacements["~" + template[i].name] = tree[i + 1];
    }
  }

  let replaceCode = function(source) {
    // handle homoiconic expressions in macro
    let ret= [],
        expr_name = source[0] ? source[0].name : "";

    ret._filename = tree._filename;
    ret._line = tree._line;

    if (isHomoiconicExpr.test(expr_name)) {
      let replarray = replacements["~" + source[1].name];
      if (expr_name === "#args-shift") {
        if (!isarray(replarray)) {
          handleError(13, tree._line, tree._filename, command);
        }
        let argshift = replarray.shift();
        if (inst(argshift) === "undefined") {
          handleError(12, tree._line, tree._filename, command);
        }
        return argshift;
      }
      if (expr_name === "#args-second") {
        if (!isarray(replarray)) {
          handleError(13, tree._line, tree._filename, command);
        }
        let argsecond = replarray.splice(1, 1)[0];
        if (inst(argsecond) === "undefined") {
          handleError(12, tree._line, tree._filename, command);
        }
        return argsecond;
      }
      if (expr_name === "#args-if") {
        if (!isarray(replarray)) {
          handleError(13, tree._line, tree._filename, command);
        }
        if (replarray.length) {
          return replaceCode(source[2]);
        } else if (source[3]) {
          return replaceCode(source[3]);
        } else {
          return;
        }
      }
    }
    for (var i = 0; i < source.length; ++i) {
      if (isarray(source[i])) {
        let replcode = replaceCode(source[i]);
        if (inst(replcode) !== "undefined") {
          ret.push(replcode);
        }
      } else {
        let token = source[i],
            tokenbak = token,
            isATSign = false;
        if (token.name.indexOf("@") >= 0) {
          isATSign = true;
          tokenbak = snode(token.line,
                           token.column,
                           token.source,
                           token.name.replace("@", ""),
                           token.name.replace("@", ""));
        }
        if (replacements[tokenbak.name]) {
          let repl = replacements[tokenbak.name];
          if (isATSign || tokenbak.name === "~rest...") {
            for (var j = 0; j < repl.length; ++j) {
              ret.push(repl[j]);
            }
          } else {
            ret.push(repl);
          }
        } else {
          ret.push(token);
        }
      }
    }
    return ret;
  }

  return replaceCode(code);
}

//////////////////////////////////////////////////////////////////////////////
//
function handleCompOperator(arr) {
  if (arr.length < 3) { handleError(0, arr._line); }
  evalSexp(arr);

  // dont use === as arr[0] is a source node
  if (arr[0] == "!=") { arr[0] = "!=="; }
  if (arr[0] == "=") { arr[0] = "==="; }

  let op = arr.shift(),
      ret = snode();

  for (var i = 0; i < arr.length - 1; ++i) {
    ret.add (snode(null, null, null, [arr[i], " ", op, " ", arr[i + 1]]));
  }

  ret.join(" && ");
  ret.prepend("(");
  ret.add(")");
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function handleArithOperator(arr) {
  if (arr.length < 3) { handleError(0, arr._line); }
  evalSexp(arr);

  let op = snode(),
      ret= snode();

  op.add([" ", arr.shift(), " "]);
  ret.add(arr);
  ret.join(op);
  ret.prepend("(");
  ret.add(")");
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function handleLogicalOperator(arr) {
  return handleArithOperator(arr);
}

//////////////////////////////////////////////////////////////////////////////
///////keywords
keywords["var"] = function(arr) {
  if (arr.length < 3) { synError(0, arr); }
  if (arr.length > 3) {
    indent += indentSize;
  }
  evalSexp(arr);
  let ret = snode();
  ret.add("var ");
  for (var i = 1; i < arr.length; i = i + 2) {
    if (i > 1) {
      ret.add(",\n" + pad(indent));
    }
    if (!validName.test(arr[i])) { synError(9, arr); }
    ret.add([arr[i], " = ", arr[i + 1]]);
  }
  if (arr.length > 3) {
    indent -= indentSize;
  }
  return ret;
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["new"] = function(arr) {
  if (arr.length < 2) { synError(0, arr); }
  let ret = snode();
  ret.add(evalForm(arr.slice(1)));
  ret.prepend("new ");
  return ret;
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["throw"] = function(arr) {
  assertArgs(arr, 2, 0);
  let ret = snode();
  ret.add(isarray(arr[1]) ? evalForm(arr[1]) : arr[1]);
  ret.prepend("(function(){throw ");
  ret.add(";})()");
  return ret;
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["set"] = function(arr) {
  if (arr.length < 3 || arr.length > 4) { synError(0, arr); }
  if (arr.length === 4) {
    arr[1] = (isarray(arr[2]) ? evalForm(arr[2]) : arr[2]) +
             "[" + arr[1] + "]";
    arr[2] = arr[3];
  }
  return snode(null, null, null,
               [arr[1],
                " = ",
                (isarray(arr[2]) ? evalForm(arr[2]) : arr[2])]);
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["function"] = function(arr) {

  if (arr.length < 2) { synError(0, arr); }

  let ret, fName, fArgs, fBody;

  if(isarray(arr[1])) {
    // an anonymous function
    fArgs = arr[1];
    fBody = arr.slice(2);
  }
  else if(!isarray(arr[1]) && isarray(arr[2])) {
    // a named function
    fName = arr[1];
    fArgs = arr[2];
    fBody = arr.slice(3);
  }
  else { handleError(0, arr._line); }

  ret = snode(null, null, null, fArgs);
  ret.join(",");
  ret.prepend("function" + (fName ? " " + fName.name : "") + "(");
  ret.add([") {\n",evalAST(fBody), pad(indent), "}"]);

  if (fName) { noSemiColon = true; }
  return ret;
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["try"] = function(arr) {
  if (arr.length < 3) { synError(0, arr); }
  let c = arr.pop(),
      ind = pad(indent),
      ret = snode();

  ret.add(["(function() {\n" + ind +
           "try {\n", evalAST(arr.slice(1)), "\n" +
           ind + "} catch (e) {\n" +
           ind + "return (", (isarray(c) ? evalForm(c) : c), ")(e);\n" +
           ind + "}\n" + ind + "})()"])
  return ret;
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["if"] = function(arr) {
  if (arr.length < 3 || arr.length > 4)  { synError(0, arr); }
  indent += indentSize;
  evalSexp(arr);

  let ret = snode();
  ret.add(["(", arr[1], " ?\n" +
           pad(indent), arr[2], " :\n" +
           pad(indent), (arr[3] || "undefined"), ")"]);
  indent -= indentSize;
  return ret;
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["get"] = function(arr) {
  assertArgs(arr, 3, 0);
  evalSexp(arr);
  return snode(null, null, null, [arr[2], "[", arr[1], "]"]);
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["str"] = function(arr) {
  if (arr.length < 2) { synError(0, arr); }
  evalSexp(arr);
  let ret = snode();
  ret.add(arr.slice(1));
  ret.join(",");
  ret.prepend("[");
  ret.add("].join('')");
  return ret;
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["array"] = function(arr) {
  let ret = snode();

  if (arr.length === 1) {
    ret.add("[]");
    return ret;
  }

  indent += indentSize;
  evalSexp(arr);

  ret.add("[\n" + pad(indent));
  for (var i = 1; i < arr.length; ++i) {
    if (i > 1) {
      ret.add(",\n" + pad(indent));
    }
    ret.add(arr[i]);
  }

  indent -= indentSize;
  ret.add("\n" + pad(indent) + "]");
  return ret;
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["object"] = function(arr) {
  let ret = snode();

  if (arr.length === 1) {
    ret.add("{}");
    return ret;
  }

  indent += indentSize;
  evalSexp(arr);

  ret.add("{\n" + pad(indent));
  for (var i = 1; i < arr.length; i = i + 2) {
    if (i > 1) {
      ret.add(",\n" + pad(indent));
    }

    ret.add([arr[i], ": ", arr[i + 1]]);
  }

  indent -= indentSize;
  ret.add("\n" + pad(indent) + "}");

  return ret;
};

//////////////////////////////////////////////////////////////////////////////
//
var includeFile = (function () {
  let icache = [];
  return function(fname) {
    if (icache.indexOf(fname) !== -1) { return ""; }
    icache.push(fname);
    return evalAST(
             toAST(fs.readFileSync(fname), fname));
  };
})();

//////////////////////////////////////////////////////////////////////////////
//
keywords["include"] = function(arr) {

  assertArgs(arr, 2, 0);

  let found=false,
      ret=snode(),
      fname = arr[1].name;

  if (inst(fname) === "string") {
    fname = fname.replace(/["']/g, "");
  }
  indent -= indentSize;

  include_dirs.
    concat([path.dirname(arr._filename)]).
    forEach(function(pfx) {
      if (found) { return; }
      try {
        fname = fs.realpathSync(pfx + '/' +fname);
        found = true;
      } catch (err) {}
    });

  if (!found) { synError(11, arr); }

  ret = includeFile(fname);
  indent += indentSize;
  return ret;
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["javascript"] = function(arr) {
  assertArgs(arr, 2, 0);
  noSemiColon = true;
  arr[1].replaceRight(/"/g, "");
  return arr[1];
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["macro"] = function(arr) {
  assertArgs(arr, 4, 0);
  macros[arr[1].name] = {template: arr[2],
                         code:     arr[3]};
  return "";
};
keywords["defmacro"] = keywords["macro"];

//////////////////////////////////////////////////////////////////////////////
//
keywords["+"] = handleArithOperator;
keywords["-"] = handleArithOperator;
keywords["*"] = handleArithOperator;
keywords["/"] = handleArithOperator;
keywords["%"] = handleArithOperator;

//////////////////////////////////////////////////////////////////////////////
//
keywords["||"] = handleLogicalOperator;
keywords["&&"] = handleLogicalOperator;
keywords["="] = handleCompOperator;
keywords["!="] = handleCompOperator;
keywords[">"] = handleCompOperator;
keywords[">="] = handleCompOperator;
keywords["<"] = handleCompOperator;
keywords["<="] = handleCompOperator;

//////////////////////////////////////////////////////////////////////////////
//
keywords["!"] = function(arr) {
  assertArgs(arr, 2, 0);
  evalSexp(arr);
  return "(!" + arr[1] + ")";
};

//////////////////////////////////////////////////////////////////////////////
//
function dbg(obj, hint) {
  if (isarray(obj)) {
    hint= hint || "block";
    console.log("<"+hint+">");
    for (var i=0; i < obj.length; ++i) {
      dbg(obj[i]);
    }
    console.log("</"+hint+">");
  } else if (isnode(obj)) {
    console.log("<node>");
    console.log(obj);
    dbg(obj.children,"subs");
    console.log("</node>");
  } else {
    console.log(obj);
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function dbgAST(codeStr, fname) {
  let tree= toAST(codeStr, fname);
  dbg(tree, "tree");
}

//////////////////////////////////////////////////////////////////////////////
//
function compileCode(codeStr, fname, withSrcMap, a_include_dirs) {

  if (a_include_dirs) { include_dirs = a_include_dirs; }
  indent = -indentSize;

  let outNode = evalAST(toAST(codeStr, fname));
  outNode.prepend(banner);

  if (withSrcMap) {
    let outFile = path.basename(fname, ".ls") + ".js",
        srcMap = outFile + ".map",
        output = outNode.toStringWithSourceMap( { file: outFile });

    fs.writeFileSync(srcMap, output.map);
    return output.code +
           "\n//# sourceMappingURL=" +
           path.relative(path.dirname(fname), srcMap);
  } else {
    return outNode.toString();
  }
}

//////////////////////////////////////////////////////////////////////////////
//
exports.transpileWithSrcMap=function(code,file,incDirs) {
  return compileCode(code,file,true,incDirs);
};
exports.transpile=function(code,file,incDirs) {
  return compileCode(code,file,false,incDirs);
};
exports.version = version;
exports.dbgAST=dbgAST;
exports.parseWithSourceMap = function(codeStr, fname) {
  let outNode = evalAST(toAST(codeStr, fname));
  outNode.prepend(banner);
  return outNode.toStringWithSourceMap();
};

//////////////////////////////////////////////////////////////////////////////
//EOF



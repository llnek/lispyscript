/*
 *
LispyScript - Javascript using tree syntax!
This is the compiler written in javascipt
 *
*/

var version = "1.5.0",
    banner = "// Generated by LispyScript v" + version + "\n",
    isWhitespace = /\s/,
    isFunction = /^function\b/,
    isFn = /^fn\b/,
    validName = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/,
    noReturn = /^var\b|^set\b|^set!\b|^throw\b/,
    isHomoiconicExpr = /^#args-if\b|^#args-shift\b|^#args-second\b/,
    noSemiColon = false,
    indentSize = 2,
    indent = -indentSize,
    keywords = {},
    macros = {},
    errors = [],
    include_dirs = [__dirname + "/../includes", "includes"],
    fs,
    path,
    SourceNode = require('source-map').SourceNode;

//////////////////////////////////////////////////////////////////////////////
//
errors[0] = "Syntax Error";
errors[1] = "Empty statement";
errors[2] = "Invalid characters in function name";
errors[3] = "End of File encountered, unterminated string";
errors[4] = "Closing square bracket, without an opening square bracket";
errors[5] = "End of File encountered, unterminated array";
errors[6] = "Closing curly brace, without an opening curly brace";
errors[7] = "End of File encountered, unterminated javascript object '}'";
errors[8] = "End of File encountered, unterminated parenthesis";
errors[9] = "Invalid character in var name";
errors[10] = "Extra chars at end of file. Maybe an extra ')'.";
errors[11] = "Cannot Open include File";
errors[12] = "Invalid no of arguments to ";
errors[13] = "Invalid Argument type to ";
errors[14] = "End of File encountered, unterminated regular expression";

//////////////////////////////////////////////////////////////////////////////
//
if (typeof window === "undefined") {
  fs = require('fs');
  path = require('path');
}

//////////////////////////////////////////////////////////////////////////////
//
if (!String.prototype.repeat) {
  String.prototype.repeat = function(num) {
    return new Array(num + 1).join(this);
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function handleError(no, line, filename, extra) {
  throw new Error(errors[no] +
                  ((extra) ? " - " + extra : "") +
                  ((line) ? "\nLine no " + line : "") +
                  ((filename) ? "\nFile " + filename : ""));
}

//////////////////////////////////////////////////////////////////////////////
//
function snode(ln,col,fn,chunk,name) {
  if (arguments.length > 0) {
    return name ? new SourceNode(ln, col, fn, chunk, name)
                : new SourceNode(ln, col, fn, chunk);
  } else {
    return new SourceNode();
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function toAST(codeStr, filename) {
  codeStr = "(" + codeStr + ")";
  let length = codeStr.length,
    pos = 1,
    lineno = 1,
    colno = 1,
    tokenBeginCol = 1,
    handleToken = function(tree,token) {
      if (token) {
        if (":else" == token) { token="true";}
        if ("nil" == token) { token="null";}
        tree.push(snode(lineno, tokenBeginCol - 1, filename, token,token));
      }
      return "";
    },
    parseError=function(c,tree) {
      handleError(c, tree._line, tree._filename);
    },
    tokenize = function() {
      let tree = [],
        token = "",
        isString = false,
        isSingleString = false,
        isJSArray = 0,
        isJSObject = 0,
        isListComplete = false,
        isComment = false,
        isRegex = false,
        isEscape = false;

      tree._filename = filename;
      tree._line = lineno;
      while (pos < length) {
        let c = codeStr.charAt(pos);
        pos++; colno++;
        if (c === "\n") {
          lineno++; colno = 1;
          if (isComment) { isComment = false; }
        }
        if (isComment) { continue; }
        if (isEscape) {
          isEscape = false; token += c; continue; }
        // strings
        if (c === '"') {
          isString = !isString; token += c; continue; }
        if (isString) {
          if (c === "\n") {
            token += "\\n";
          }
          else {
            if (c === "\\") { isEscape = true; }
            token += c;
          }
          continue;
        }
        if (c === "'") {
          isSingleString = !isSingleString;
          token += c;
          continue;
        }
        if (isSingleString) {
          token += c;
          continue;
        }
        // data types
        if (c === "[") {
          isJSArray++;
          token += c;
          continue;
        }
        if (c === "]") {
          if (isJSArray === 0) {
            parseError(4, tree);
          }
          isJSArray--;
          token += c;
          continue;
        }
        if (isJSArray) {
          token += c;
          continue;
        }
        if (c == "{") {
          isJSObject++;
          token += c;
          continue;
        }
        if (c == '}') {
          if (isJSObject === 0) {
            parseError(6, tree);
          }
          isJSObject--;
          token += c;
          continue;
        }
        if (isJSObject) {
          token += c;
          continue;
        }
        if (c === ";") {
          isComment = true;
          continue;
        }
        // regex
        // regex in function position with first char " " is a prob. Use \s instead.
        if (c === "/"&&
            !(tree.length === 0 &&
              token.length === 0 &&
              isWhitespace.test(codeStr.charAt(pos)))) {
          isRegex = !isRegex;
          token += c;
          continue;
        }
        if (isRegex) {
          if (c === "\\") {
            isEscape = true;
          }
          token += c;
          continue;
        }
        if (c === "(") {
          token=handleToken(tree,token); // catch e.g. "blah("
          tokenBeginCol = colno;
          tree.push(tokenize());
          continue;
        }
        if (c === ")") {
          isListComplete = true;
          token=handleToken(tree,token);
          tokenBeginCol = colno;
          break;
        }
        if (isWhitespace.test(c)) {
          if (c === "\n") { lineno--; }
          token=handleToken(tree,token);
          if (c === "\n") { lineno++; }
          tokenBeginCol = colno;
          continue;
        }
        token += c;
      }
      if (isString || isSingleString) { parseError(3, tree);}
      if (isRegex) { parseError(14, tree); }
      if (isJSArray > 0) { parseError(5, tree); }
      if (isJSObject > 0) { parseError(7, tree); }
      if (!isListComplete) { parseError(8, tree); }
      return tree;
    },
    ret = tokenize();
    return (pos < length) ? handleError(10) : ret;
}

//////////////////////////////////////////////////////////////////////////////
// [expr,...] -> SourceNode
function handleExpressions(astTree) {
  let ret = snode(),
    len = astTree.length;

  indent += indentSize;
  indentstr = " ".repeat(indent);

  astTree.forEach(function(expr, i, tree) {
    let exprName, tmp = null, r = "";
    if (Array.isArray(expr)) {
      exprName = expr[0].name
      if (exprName === "include") {
        ret.add(handleExpression(expr));
      } else {
        tmp = handleExpression(expr) ;
      }
    } else {
      tmp = expr;
    }
    if (i === len - 1 && indent) {
      if (!noReturn.test(exprName)) {r = "return "; }
    }
    if (tmp) {
      let endline = noSemiColon ? "\n" : ";\n";
      noSemiColon = false;
      ret.add([indentstr + r, tmp, endline]);
    }
  });

  indent -= indentSize;
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function handleExpression(expr) {

  if (!expr || !expr[0]) { return null; }
  let command = expr[0].name;

  if (macros[command]) {
    expr = macroExpand(expr);
    if (Array.isArray(expr)) {
      return handleExpression(expr);
    } else {
      return expr;
    }
  }

  if (typeof command === "string") {
    if (keywords[command]) {
      return keywords[command](expr);
    }
    if (command.charAt(0) === ".") {
      let ret = snode();
      ret.add(Array.isArray(expr[1]) ? handleExpression(expr[1]) : expr[1]);
      ret.prepend("(");
      ret.add([")", expr[0]]);
      return ret;
    }
  }
  handleSubExpressions(expr);
  let fName = expr[0];
  if (!fName) {
    handleError(1, expr._line);
  }
  if (isFunction.test(fName) || isFn.test(fName)) {
    fName = snode(null, null, null, ['(', fName, ')']);
  }
  exprNode = snode(null, null, null, expr.slice(1)).join(",");
  return snode(null, null, null, [fName, "(", exprNode, ")"]);
}

//////////////////////////////////////////////////////////////////////////////
//
function handleSubExpressions(expr) {
  expr.forEach(function(value, i, t) {
    if (Array.isArray(value)) t[i] = handleExpression(value);
  })
}

//////////////////////////////////////////////////////////////////////////////
//
function macroExpand(tree) {
    var command = tree[0].name,
        template = macros[command]["template"],
        code = macros[command]["code"],
        replacements = {}

    for (var i = 0; i < template.length; i++) {
        if (template[i].name == "rest...") {
            replacements["~rest..."] = tree.slice(i + 1)
        } else {
            if (tree.length === i + 1) {
                // we are here if any macro arg is not set
                handleError(12, tree._line, tree._filename, command)
            }

            replacements["~" + template[i].name] = tree[i + 1]
        }
    }
    var replaceCode = function(source) {
        var ret = []
        ret._line = tree._line
        ret._filename = tree._filename

        // Handle homoiconic expressions in macro
        var expr_name = source[0] ? source[0].name : ""

        if (isHomoiconicExpr.test(expr_name)) {
            var replarray = replacements["~" + source[1].name]
            if (expr_name === "#args-shift") {
                if (!Array.isArray(replarray)) {
                    handleError(13, tree._line, tree._filename, command)
                }
                var argshift = replarray.shift()
                if (typeof argshift === "undefined") {
                    handleError(12, tree._line, tree._filename, command)
                }
                return argshift
            }
            if (expr_name === "#args-second") {
                if (!Array.isArray(replarray)) {
                    handleError(13, tree._line, tree._filename, command)
                }
                var argsecond = replarray.splice(1, 1)[0]
                if (typeof argsecond === "undefined") {
                    handleError(12, tree._line, tree._filename, command)
                }
                return argsecond
            }
            if (expr_name === "#args-if") {
                if (!Array.isArray(replarray)) {
                    handleError(13, tree._line, tree._filename, command)
                }
                if (replarray.length) {
                    return replaceCode(source[2])
                } else if (source[3]) {
                    return replaceCode(source[3])
                } else {
                    return
                }
            }
        }
        for (var i = 0; i < source.length; i++) {
            if (Array.isArray(source[i])) {

                var replcode = replaceCode(source[i])
                if (typeof replcode !== "undefined") {
                    ret.push(replcode)
                }
            } else {
                var token = source[i],
                    tokenbak = token,
                    isATSign = false
                if (token.name.indexOf("@") >= 0) {
                    isATSign = true
                    tokenbak = new SourceNode(token.line, token.column, token.source, token.name.replace("@", ""), token.name.replace("@", ""))
                }

                if (replacements[tokenbak.name]) {
                    var repl = replacements[tokenbak.name]
                    if (isATSign || tokenbak.name == "~rest...") {
                        for (var j = 0; j < repl.length; j++) {
                            ret.push(repl[j])
                        }
                    } else {
                        ret.push(repl)
                    }
                } else {
                    ret.push(token)
                }
            }
        }
        return ret
    }
    return replaceCode(code)
}

//////////////////////////////////////////////////////////////////////////////
//
function handleCompOperator(arr) {
    if (arr.length < 3)  handleError(0, arr._line)
    handleSubExpressions(arr)
    if (arr[0] == "=") arr[0] = "==="
    if (arr[0] == "!=") arr[0] = "!=="

    var op = arr.shift()
    var ret = new SourceNode()

    for (i = 0; i < arr.length - 1; i++)
        ret.add (new SourceNode (null, null, null, [arr[i], " ", op, " ", arr[i + 1]]))

    ret.join (' && ')

    ret.prepend('(')
    ret.add(')')

    return ret

}

//////////////////////////////////////////////////////////////////////////////
//
function handleArithOperator(arr) {
    if (arr.length < 3)  handleError(0, arr._line)
    handleSubExpressions(arr)

    var op = new SourceNode()
    op.add([" ", arr.shift(), " "])

    var ret = new SourceNode()
    ret.add(arr)

    ret.join (op)

    ret.prepend("(")
    ret.add(")")

    return ret
}

//////////////////////////////////////////////////////////////////////////////
//
function handleLogicalOperator(arr) {
  return handleArithOperator(arr);
}

//////////////////////////////////////////////////////////////////////////////
//
/////keywords
keywords["var"] = function(arr) {
    if (arr.length < 3) handleError(0, arr._line, arr._filename)
    if (arr.length > 3) {
        indent += indentSize
    }
    handleSubExpressions(arr)
    var ret = new SourceNode ()
    ret.add("var ")

    for (var i = 1; i < arr.length; i = i + 2) {
        if (i > 1) {
            ret.add(",\n" + " ".repeat(indent))
        }
        if (!validName.test(arr[i])) handleError(9, arr._line, arr._filename)
        ret.add([arr[i], ' = ', arr[i + 1]])
    }
    if (arr.length > 3) {
        indent -= indentSize
    }
    return ret
}

keywords["new"] = function(arr) {
    if (arr.length < 2) handleError(0, arr._line, arr._filename)

    var ret = new SourceNode()

    ret.add(handleExpression(arr.slice(1)))
    ret.prepend ("new ")

    return ret
}

keywords["throw"] = function(arr) {
    if (arr.length != 2)  handleError(0, arr._line, arr._filename)

    var ret = new SourceNode()

    ret.add(Array.isArray(arr[1]) ? handleExpression(arr[1]) : arr[1])
    ret.prepend("(function(){throw ")
    ret.add(";})()")

    return ret
}

keywords["set"] = function(arr) {
    if (arr.length < 3 || arr.length > 4) handleError(0, arr._line, arr._filename)
    if (arr.length == 4) {
        arr[1] = (Array.isArray(arr[2]) ? handleExpression(arr[2]) : arr[2]) + "[" + arr[1] + "]"
        arr[2] = arr[3]
    }
    return new SourceNode(null, null, null,
            [arr[1], " = ", (Array.isArray(arr[2]) ? handleExpression(arr[2]) : arr[2])])
}

keywords["function"] = function(arr) {

    var ret
    var fName, fArgs, fBody

    if (arr.length < 2) handleError(0, arr._line, arr._filename)

    if(Array.isArray(arr[1])) {
        // an anonymous function
        fArgs = arr[1]
        fBody = arr.slice(2)
    }
    else if(!Array.isArray(arr[1]) && Array.isArray(arr[2])) {
        // a named function
        fName = arr[1]
        fArgs = arr[2]
        fBody = arr.slice(3)
    }
    else
        handleError(0, arr._line)

    ret = new SourceNode(null, null, null, fArgs)
    ret.join(",")
    ret.prepend("function" + (fName ? " " + fName.name : "") + "(")
    ret.add([") {\n",handleExpressions(fBody),
               " ".repeat(indent), "}"])

    if(fName)
        noSemiColon = true

    return ret
}

keywords["try"] = function(arr) {
    if (arr.length < 3) handleError(0, arr._line, arr._filename)
    var c = arr.pop(),
        ind = " ".repeat(indent),
        ret = new SourceNode()

    ret.add(["(function() {\n" + ind +
           "try {\n", handleExpressions(arr.slice(1)), "\n" +
           ind + "} catch (e) {\n" +
           ind + "return (", (Array.isArray(c) ? handleExpression(c) : c), ")(e);\n" +
           ind + "}\n" + ind + "})()"])

    return ret
}

keywords["if"] = function(arr) {
    if (arr.length < 3 || arr.length > 4)  handleError(0, arr._line, arr._filename)
    indent += indentSize
    handleSubExpressions(arr)

    var ret = new SourceNode()
    ret.add(["(", arr[1], " ?\n" +
        " ".repeat(indent), arr[2], " :\n" +
        " ".repeat(indent), (arr[3] || "undefined"), ")"])
    indent -= indentSize
    return ret
}

keywords["get"] = function(arr) {
    if (arr.length != 3) handleError(0, arr._line, arr._filename)
    handleSubExpressions(arr)
    return new SourceNode(null, null, null, [arr[2], "[", arr[1], "]"])
}

keywords["str"] = function(arr) {
    if (arr.length < 2) handleError(0, arr._line, arr._filename)
    handleSubExpressions(arr)
    var ret = new SourceNode()
    ret.add(arr.slice(1))
    ret.join (",")
    ret.prepend("[")
    ret.add("].join('')")

    return ret
}

keywords["array"] = function(arr) {
    var ret = new SourceNode()

    if (arr.length == 1) {
        ret.add("[]")
        return ret
    }

    indent += indentSize
    handleSubExpressions(arr)

    ret.add("[\n" + " ".repeat(indent))
    for (var i = 1; i < arr.length; ++i) {
        if (i > 1) {
            ret.add(",\n" + " ".repeat(indent))
        }
        ret.add(arr[i])
    }
    indent -= indentSize

    ret.add("\n" + " ".repeat(indent) + "]")

    return ret
}

keywords["object"] = function(arr) {
    var ret = new SourceNode()

    if (arr.length == 1) {
        ret.add("{}")
        return ret
    }

    indent += indentSize
    handleSubExpressions(arr)

    ret.add("{\n" + " ".repeat(indent))

    for (var i = 1; i < arr.length; i = i + 2) {
        if (i > 1) {
            ret.add(",\n" + " ".repeat(indent))
        }

        ret.add([arr[i], ': ', arr[i + 1]])
    }

    indent -= indentSize
    ret.add("\n" + " ".repeat(indent) + "}")

    return ret
}

//////////////////////////////////////////////////////////////////////////////
//
var includeFile = (function () {
  let icache = [];
  return function(fname) {
    if (icache.indexOf(fname) !== -1) { return ""; }
    icache.push(fname);
    return handleExpressions(
             toAST(fs.readFileSync(fname), fname));
  };
})();

//////////////////////////////////////////////////////////////////////////////
//
function synError(c,arr) {
  return handleError(c, arr._line, arr._filename);
}

//////////////////////////////////////////////////////////////////////////////
//
function inst(obj) { return typeof obj; }

//////////////////////////////////////////////////////////////////////////////
//
keywords["include"] = function(arr) {

  if (arr.length !== 2) { synError(0, arr); }

  let found=false,
      ret=snode(),
      fname = arr[1].name;

  indent -= indentSize;
  if (inst(fname) === "string") {
    fname = fname.replace(/["']/g, "");
  }

  include_dirs.
    concat([path.dirname(arr._filename)]).
    forEach(function(pfx) {
      if (found) { return; }
      try {
        fname = fs.realpathSync(pfx + '/' +fname);
        found = true;
      } catch (err) {}
    });

  if (!found) { synError(11, arr); }

  ret = includeFile(fname);
  indent += indentSize;
  return ret;
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["javascript"] = function(arr) {
  if (arr.length !== 2) { synError(0, arr); }
  noSemiColon = true;
  arr[1].replaceRight(/"/g, '');
  return arr[1];
};

//////////////////////////////////////////////////////////////////////////////
//
keywords["macro"] = function(arr) {
  if (arr.length !== 4) { synError(0, arr); }
  macros[arr[1].name] = {template: arr[2],
                         code:     arr[3]};
  return "";
};
keywords["defmacro"] = keywords["macro"];

//////////////////////////////////////////////////////////////////////////////
//
keywords["+"] = handleArithOperator;
keywords["-"] = handleArithOperator;
keywords["*"] = handleArithOperator;
keywords["/"] = handleArithOperator;
keywords["%"] = handleArithOperator;

//////////////////////////////////////////////////////////////////////////////
//
keywords["="] = handleCompOperator;
keywords["!="] = handleCompOperator;
keywords[">"] = handleCompOperator;
keywords[">="] = handleCompOperator;
keywords["<"] = handleCompOperator;
keywords["<="] = handleCompOperator;
keywords["||"] = handleLogicalOperator;
keywords["&&"] = handleLogicalOperator;

//////////////////////////////////////////////////////////////////////////////
//
keywords["!"] = function(arr) {
  if (arr.length !== 2) { synError(0, arr); }
  handleSubExpressions(arr);
  return "(!" + arr[1] + ")";
};

//////////////////////////////////////////////////////////////////////////////
//
exports.parseWithSourceMap = function(codeStr, fname) {
  let outNode = handleExpressions(toAST(codeStr, fname));
  outNode.prepend(banner);
  return outNode.toStringWithSourceMap();
};

//////////////////////////////////////////////////////////////////////////////
//
exports._compile = function (codeStr,
                             fname,
                             withSrcMap,
                             a_include_dirs) {

  if (a_include_dirs) { include_dirs = a_include_dirs; }
  indent = -indentSize;

  let outNode = handleExpressions(toAST(codeStr, fname));
  outNode.prepend(banner);

  if (withSrcMap) {
    let outFile = path.basename(fname, '.ls') + '.js',
        srcMap = outFile + '.map',
        output = outNode.toStringWithSourceMap( { file: outFile });

    fs.writeFileSync(srcMap, output.map);
    return output.code +
           "\n//# sourceMappingURL=" +
           path.relative(path.dirname(fname), srcMap);
  } else {
    return outNode.toString();
  }
}

//////////////////////////////////////////////////////////////////////////////
//
exports.version = version;

//////////////////////////////////////////////////////////////////////////////
//EOF



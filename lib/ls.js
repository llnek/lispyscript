/*
 *
LispyScript - Javascript using tree syntax!
This is the compiler written in javascipt
 *
*/

var version = "1.5.0",
    banner = "// Generated by LispyScript v" + version + "\n",
    isWhitespace = /\s/,
    isFunction = /^function\b|^defn\b|^fn\b/,
    validName = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/,
    noReturn = /^def\b|^var\b|^set\b|^set!\b|^throw\b/,
    isHomoiconicExpr = /^#args-if\b|^#args-shift\b|^#args-second\b/,
    include_dirs = [__dirname + "/../includes", "includes"],
    noSemiColon = false,
    indentSize = 2,
    indent = -indentSize,
    MACROS_MAP = {},
    fs,
    path,
    SourceNode = require("source-map").SourceNode;

//////////////////////////////////////////////////////////////////////////////
//
var ERRORS_MAP= {
  e0: "Syntax Error",
  e1: "Empty statement",
  e2: "Invalid characters in function name",
  e3: "End of File encountered, unterminated string",
  e4: "Closing square bracket, without an opening square bracket",
  e5: "End of File encountered, unterminated array",
  e6: "Closing curly brace, without an opening curly brace",
  e7: "End of File encountered, unterminated javascript object '}'",
  e8: "End of File encountered, unterminated parenthesis",
  e9: "Invalid character in var name",
  e10: "Extra chars at end of file. Maybe an extra ')'.",
  e11: "Cannot Open include File",
  e12: "Invalid no of arguments to ",
  e13: "Invalid Argument type to ",
  e14: "End of File encountered, unterminated regular expression"};

//////////////////////////////////////////////////////////////////////////////
//
if (typeof window === "undefined") {
  path = require("path");
  fs = require("fs");
}

//////////////////////////////////////////////////////////////////////////////
//
if (!String.prototype.repeat) {
  String.prototype.repeat = function(num) {
    return new Array(num + 1).join(this);
  };
}

//////////////////////////////////////////////////////////////////////////////
//
function assert(cond, msg) {
  if (! cond) { throw new Error(msg); }
}

//////////////////////////////////////////////////////////////////////////////
//
function whatis(obj) {
  return Object.prototype.toString.call(obj);
}

//////////////////////////////////////////////////////////////////////////////
//
function isobject(obj) {
  return whatis(obj) === "[object Object]";
}

//////////////////////////////////////////////////////////////////////////////
//
function isstr(obj) {
  return whatis(obj) === "[object String]";
}

/*
Object.prototype.toString.call(new Date()); // [object Date]
Object.prototype.toString.call(1); // [object Number]
Object.prototype.toString.call(function () {}); // [object Function]
Object.prototype.toString.call(/test/i); // [object RegExp]
Object.prototype.toString.call(true); // [object Boolean]
Object.prototype.toString.call(null); // [object Null]
Object.prototype.toString.call(); // [object Undefined]
*/
//////////////////////////////////////////////////////////////////////////////
//
function isnode(obj) {
  return isobject(obj) && obj["$$$isSourceNode$$$"] === true;
}

//////////////////////////////////////////////////////////////////////////////
//
function handleError(no, line, filename, extra) {
  throw new Error(ERRORS_MAP[no] +
                  ((extra) ? " - " + extra : "") +
                  ((line) ? "\nLine no " + line : "") +
                  ((filename) ? "\nFile " + filename : ""));
}

//////////////////////////////////////////////////////////////////////////////
//
function synError(c,arr,cmd) {
  return handleError(c, arr._line, arr._filename,cmd);
}

//////////////////////////////////////////////////////////////////////////////
//
function assertArgs(arr, cnt, err) {
  if (arr.length !== cnt) { synError(err, arr); }
}

//////////////////////////////////////////////////////////////////////////////
//
function assertForm(f) {
  if (! isform(f)) {
    console.log("expecting form, got: " + whatis(f));
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function assertNode(n) {
  if (! isnode(n)) {
    console.log("expecting node, got: " + whatis(n));
    if (isform(n)) {
      console.log("expecting node, line: " + n._line);
    }
    assert(false, "source node expected");
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function inst(obj) { return typeof obj; }

//////////////////////////////////////////////////////////////////////////////
//
function isarray(a) { return Array.isArray(a); }
function isform(a) { return Array.isArray(a); }

//////////////////////////////////////////////////////////////////////////////
//
function pad(z) { return " ".repeat(z); }

//////////////////////////////////////////////////////////////////////////////
//
function snode(ln,col,fn,chunk,name) {
  if (arguments.length > 0) {
    return name ? new SourceNode(ln, col, fn, chunk, name)
                : new SourceNode(ln, col, fn, chunk);
  } else {
    return new SourceNode();
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function snodeChunk(chunk) {
  return snode(null,null,null,chunk);
}

//////////////////////////////////////////////////////////////////////////////
//
function toAST(codeStr, filename) {
  codeStr = "(" + codeStr + ")";
  let length = codeStr.length,
      pos = 1,
      lineno = 1,
      colno = 1,
      tknCol = 1,
      addToken = function(tree,token) {
        if (token) {
          if (":else" == token) { token="true";}
          if ("nil" == token) { token="null";}
          tree.push(snode(lineno,
                          tknCol - 1,
                          filename, token, token));
        }
        return "";
      },
      parseError=function(c,tree) {
        synError(c, tree);
      };
  let lexer = function() {
    let tree = [],
        token = "",
        c,
        jsArray = 0,
        jsObject = 0,
        isEsc= false,
        isStr = false,
        isSQStr = false,
        isRegex = false,
        isComment = false,
        isEndForm = false;
    tree._filename = filename;
    tree._line = lineno;
    while (pos < length) {
      c = codeStr.charAt(pos);
      ++colno;
      ++pos;
      if (c === "\n") {
        ++lineno;
        colno = 1;
        if (isComment) {
          isComment = false; }
      }
      if (isComment) { continue; }
      if (isEsc) {
        isEsc= false; token += c; continue; }
      // strings
      if (c === '"') {
        isStr = !isStr; token += c; continue; }
      if (isStr) {
        if (c === "\n") {
          token += "\\n"; }
        else {
          if (c === "\\") { isEsc= true; }
          token += c;
        }
        continue;
      }
      if (c === "'") {
        isSQStr = !isSQStr;
        token += c; continue; }
      if (isSQStr) {
        token += c; continue; }
      // data types
      if (c === "[") {
        ++jsArray;
        token += c; continue; }
      if (c === "]") {
        if (jsArray === 0) {
          parseError("e4", tree); }
        --jsArray;
        token += c; continue; }
      if (jsArray > 0) {
        token += c; continue; }
      if (c === "{") {
        ++jsObject;
        token += c; continue; }
      if (c === "}") {
        if (jsObject === 0) {
          parseError("e6", tree); }
        --jsObject;
        token += c; continue; }
      if (jsObject > 0) {
        token += c; continue; }
      if (c === ";") {
        isComment = true; continue; }
      // regex
      // regex in function position with first char " " is a prob. Use \s instead.
      if (c === "/"&&
          !(tree.length === 0 &&
            token.length === 0 &&
            isWhitespace.test(codeStr.charAt(pos)))) {
        isRegex = !isRegex;
        token += c; continue; }
      if (isRegex) {
        if (c === "\\") {
          isEsc= true; }
        token += c; continue; }
      if (c === "(") {
        token=addToken(tree,token); // catch e.g. "blah("
        tknCol = colno;
        tree.push(lexer());
        continue;
      }
      if (c === ")") {
        isEndForm = true;
        token=addToken(tree,token);
        tknCol = colno;
        break;
      }
      if (isWhitespace.test(c)) {
        if (c === "\n") { --lineno; }
        token=addToken(tree,token);
        if (c === "\n") { ++lineno; }
        tknCol = colno;
        continue;
      }
      token += c;
    }
    if (isStr || isSQStr) { parseError("e3", tree);}
    if (isRegex) { parseError("e14", tree); }
    if (jsArray > 0) { parseError("e5", tree); }
    if (jsObject > 0) { parseError("e7", tree); }
    if (!isEndForm) { parseError("e8", tree); }
    return tree;
  },
  ret = lexer();
  return (pos < length) ? handleError("e10") : ret;
}

//////////////////////////////////////////////////////////////////////////////
// [expr,...] -> SourceNode
function evalAST(astTree) {
  let ret = snode(),
      pstr = "",
      len = astTree.length;

  indent += indentSize;
  pstr = pad(indent);

  astTree.forEach(function(expr, i, tree) {
    let name="", tmp = null, r = "";
    if (isform(expr)) {
      if (isnode(expr[0])) {
        name = expr[0].name;
      }
      tmp = evalForm(expr) ;
      if (name === "include") {
        ret.add(tmp);
        tmp=null;
      }
    } else {
      tmp = expr;
    }
    if (i === len - 1 &&
        indent &&
        !noReturn.test(name)) {
      r = "return ";
    }
    if (tmp) {
      ret.add([pstr + r,
               tmp, noSemiColon ? "\n" : ";\n"]);
      noSemiColon = false;
    }
  });

  indent -= indentSize;
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function evalForm(form) {

  if (!form || !form[0]) { return null; }

  let cmd = "",
      mc=null;

  if (isnode(form[0])) {
    cmd=form[0].name;
    mc= MACROS_MAP[cmd];
  }

  if (mc) {
    let m = evalMacro(mc, cmd, form);
    return isform(m) ? evalForm(m) : m;
  }

  if (isstr(cmd)) {
    if (cmd.charAt(0) === ".") {
      let ret = snode();
      ret.add(isform(form[1])
              ? evalForm(form[1]) : form[1]);
      ret.prepend("(");
      ret.add([")", form[0]]);
      return ret;
    }
    switch (cmd) {
      case "var": return sf_var(form, "let");
      case "def": return sf_var(form, "var");
      case "new": return sf_new(form);
      case "throw": return sf_throw(form);
      case "set!": return sf_set(form);
      case "get": return sf_get(form);
      case "defn": return sf_func(form);
      case "function":
      case "fn": return sf_anonFunc(form);
      case "try": return sf_try(form);
      case "if": return sf_if(form);
      case "str": return sf_str(form);
      case "array": return sf_array(form);
      case "object": return sf_object(form);
      case "include": return sf_include(form);
      case "js#": return sf_jscode(form);
      case "defmacro":
      case "macro": return sf_macro(form);
      case "+":
      case "-":
      case "*":
      case "/":
      case "%":
        return handleArithOperator(form);
      break;
      case "||":
      case "&&":
        return handleLogicalOperator(form);
      break;
      case "!=":
      case "=":
      case ">":
      case ">=":
      case "<":
      case "<=":
        return handleCompOperator(form);
      break;
      case "!":
        return sf_not(form);
      break;
    }
  }

  evalSexp(form);

  let fName = form[0];
  if (!fName) {
    handleError(1, form._line);
  }

  if (isFunction.test(fName)) {
    fName = snodeChunk(["(", fName, ")"]);
  }

  return snodeChunk([fName, "(",
                     snodeChunk(form.slice(1)).join(","), ")"]);
}

//////////////////////////////////////////////////////////////////////////////
//
function evalSexp(sexp) {
  sexp.forEach(function(part, i, t) {
    if (isform(part)) { t[i] = evalForm(part); }
  });
}

//////////////////////////////////////////////////////////////////////////////
//
function evalMacro(mc, cmd, tree) {
  let args = mc["args"],
      code = mc["code"],
      frags = {};

  for (var i = 0; i < args.length; ++i) {
    if (args[i].name === "rest...") {
      frags["~rest..."] = tree.slice(i + 1);
      if (i !== (args.length-1)) {
        synError("e12", tree,
                 "rest... must be last arg");
      }
      break;
    } else {
      if (tree.length === i + 1) {
        // we are here if any macro arg is not set
        synError("e12", tree, cmd);
      }
      frags["~" + args[i].name] = tree[i + 1];
    }
  }

  let replaceCode = function(source) {
    // handle homoiconic expressions in macro
    let ret= [],
        sname = "";

    ret._filename = tree._filename;
    ret._line = tree._line;

    if (isnode(source[0])) {
      sname=source[0].name;
    }

    if (isHomoiconicExpr.test(sname)) {
      let replarray = frags["~" + source[1].name];
      if (sname === "#args-shift") {
        if (!isarray(replarray)) {
          synError("e13", tree, cmd);
        }
        let argshift = replarray.shift();
        if (inst(argshift) === "undefined") {
          synError("e12", tree, cmd);
        }
        return argshift;
      }
      if (sname === "#args-second") {
        if (!isarray(replarray)) {
          synError("e13", tree, cmd);
        }
        let argsecond = replarray.splice(1, 1)[0];
        if (inst(argsecond) === "undefined") {
          synError("e12", tree, cmd);
        }
        return argsecond;
      }
      if (sname === "#args-if") {
        if (!isarray(replarray)) {
          synError("e13", tree, cmd);
        }
        if (replarray.length > 0) {
          return replaceCode(source[2]);
        } else if (source[3]) {
          return replaceCode(source[3]);
        } else {
          return;
        }
      }
    }

    for (var i = 0; i < source.length; ++i) {
      if (isarray(source[i])) {
        let replcode = replaceCode(source[i]);
        if (inst(replcode) !== "undefined") {
          ret.push(replcode);
        }
      } else {
        let token = source[i],
            tokenbak = token,
            isATSign = false;
        if (token.name.indexOf("@") >= 0) {
          isATSign = true;
          tokenbak = snode(token.line,
                           token.column,
                           token.source,
                           token.name.replace("@", ""),
                           token.name.replace("@", ""));
        }
        if (frags[tokenbak.name]) {
          let repl = frags[tokenbak.name];
          if (isATSign || tokenbak.name === "~rest...") {
            for (var j = 0; j < repl.length; ++j) {
              ret.push(repl[j]);
            }
          } else {
            ret.push(repl);
          }
        } else {
          ret.push(token);
        }
      }
    }
    return ret;
  }

  return replaceCode(code);
}

//////////////////////////////////////////////////////////////////////////////
//
function handleCompOperator(arr) {
  if (arr.length < 3) { synError("e0", arr); }
  evalSexp(arr);

  // dont use === as arr[0] is a source node
  if (arr[0] == "!=") { arr[0] = "!=="; }
  if (arr[0] == "=") { arr[0] = "==="; }

  let op = arr.shift(),
      ret = snode();

  for (var i = 0; i < arr.length - 1; ++i) {
    ret.add(snodeChunk([arr[i], " ", op, " ", arr[i + 1]]));
  }

  ret.join(" && ");
  ret.prepend("(");
  ret.add(")");
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function handleArithOperator(arr) {
  if (arr.length < 3) { synError("e0", arr); }
  evalSexp(arr);

  let op = snode(),
      ret= snode();

  op.add([" ", arr.shift(), " "]);
  ret.add(arr);
  ret.join(op);
  ret.prepend("(");
  ret.add(")");
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function handleLogicalOperator(arr) {
  return handleArithOperator(arr);
}

//////////////////////////////////////////////////////////////////////////////
//special forms
//////////////////////////////////////////////////////////////////////////////
function sf_var(form, cmd) {

  if (form.length < 3 ||
      0 === (form.length % 2)) {
    synError("e0", form); }

  if (form.length > 3) {
    indent += indentSize; }

  evalSexp(form);
  let ret = snode();
  for (var i = 1; i < form.length; i = i + 2) {
    if (i > 1) {
      ret.add(",\n" + pad(indent));
    }
    if (!validName.test(form[i])) { synError("e9", form); }
    ret.add([form[i], " = ", form[i + 1]]);
  }
  ret.prepend(" ");
  ret.prepend(cmd);
  if (form.length > 3) {
    indent -= indentSize; }
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_new(form) {
  if (form.length < 2) { synError("e0", form); }
  let ret = snode();
  ret.add(evalForm(form.slice(1)));
  ret.prepend("new ");
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_throw(form) {
  assertArgs(form, 2, "e0");
  let ret = snode();
  ret.add(isform(form[1]) ? evalForm(form[1]) : form[1]);
  //ret.prepend("(function(){ throw ");
  //ret.add(";})()");
  ret.prepend("throw ");
  ret.add(";");
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_set(form) {
  if (form.length < 3 || form.length > 4) {
    synError("e0", form); }
  if (form.length === 4) {
    if (isform(form[1])) { form[1]= evalForm(form[1]); }
    if (isform(form[2])) { form[2]= evalForm(form[2]); }
    form[1] = form[1] + "[" + form[2] + "]";
    form[2] = form[3];
  }
  return snodeChunk([form[1],
                     " = ",
                     isform(form[2]) ? evalForm(form[2]) : form[2]]);
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_anonFunc(arr) {
  if (arr.length < 2) { synError("e0", arr); }

  if (! isform(arr[1])) {
    synError("e0", arr);
  }

  let fArgs = arr[1],
      fBody = arr.slice(2),
      ret = snodeChunk(fArgs);
  ret.join(",");
  ret.prepend("function (");
  ret.add([") {\n",evalAST(fBody), pad(indent), "}"]);
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_func(arr) {

  if (arr.length < 2) { synError("e0", arr); }

  let ret, fName, fArgs, fBody;

  if (!isform(arr[1]) && isform(arr[2])) {
    fName = arr[1];
    fArgs = arr[2];
    fBody = arr.slice(3);
  }
  else { synError("e0", arr); }

  ret = snodeChunk(fArgs);
  ret.join(",");
  ret.prepend("function " + fName.name + "(");
  ret.add([") {\n",evalAST(fBody), pad(indent), "}"]);
  noSemiColon = true;
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_try(arr) {

  if (arr.length < 3) { synError("e0", arr); }

  let ind = pad(indent), c = arr.pop();

  return snodeChunk(["(function() {\n" + ind + "try {\n",
                     evalAST(arr.slice(1)),
                     "\n" + ind + "} catch (e) {\n" + ind + "return (",
                     (isform(c) ? evalForm(c) : c),
                     ")(e);\n" + ind + "}\n" + ind + "})()"]);
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_if(arr) {
  if (arr.length < 3 || arr.length > 4)  {
    synError("e0", arr); }
  indent += indentSize;
  evalSexp(arr);
  try {
    return snodeChunk(["(",
                       arr[1],
                       " ?\n" + pad(indent),
                       arr[2],
                       " :\n" + pad(indent),
                       (arr[3] || "undefined"), ")"]);
  } finally {
    indent -= indentSize;
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_get(arr) {
  assertArgs(arr, 3, "e0");
  evalSexp(arr);
  return snodeChunk([arr[1], "[", arr[2], "]"]);
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_str(arr) {
  if (arr.length < 2) { synError("e0", arr); }
  evalSexp(arr);
  let ret = snode();
  ret.add(arr.slice(1));
  ret.join(",");
  ret.prepend("[");
  ret.add("].join('')");
  return ret;
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_array(arr) {
  let ret = snode(),
      p= pad(indent),
      epilog="\n" + p + "]";

  if (arr.length === 1) {
    ret.add("[]");
    return ret;
  }

  try {
    indent += indentSize;
    evalSexp(arr);
    p= pad(indent);
    ret.add("[\n" + p);
    for (var i = 1; i < arr.length; ++i) {
      if (i > 1) {
        ret.add(",\n" + p);
      }
      ret.add(arr[i]);
    }
    ret.add(epilog);
    return ret;
  } finally {
    indent -= indentSize;
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_object(arr) {
  let ret = snode(),
      p= pad(indent),
      epilog= "\n" + p + "}";

  if (arr.length === 1) {
    ret.add("{}");
    return ret;
  }

  try {
    indent += indentSize;
    evalSexp(arr);
    p=pad(indent);
    ret.add("{\n" + p);
    for (var i = 1; i < arr.length; i = i + 2) {
      if (i > 1) {
        ret.add(",\n" + p); }
      ret.add([arr[i], ": ", arr[i + 1]]);
    }
    ret.add(epilog);
    return ret;
  } finally {
    indent -= indentSize;
  }
}

//////////////////////////////////////////////////////////////////////////////
//
var includeFile = (function () {
  let icache = [];
  return function(fname) {
    if (icache.indexOf(fname) !== -1) { return ""; }
    icache.push(fname);
    return evalAST(toAST(fs.readFileSync(fname), fname));
  };
})();

//////////////////////////////////////////////////////////////////////////////
//
function sf_include(arr) {

  assertArgs(arr, 2, "e0");

  let found=false,
      fname = arr[1].name;

  if (isstr(fname)) {
    fname = fname.replace(/["']/g, ""); }
  indent -= indentSize;

  include_dirs.
    concat([path.dirname(arr._filename)]).
    forEach(function(pfx) {
      if (found) { return; }
      try {
        fname = fs.realpathSync(pfx + '/' +fname);
        found = true;
      } catch (err) {}
    });

  if (!found) { synError("e11", arr); }

  try {
    return includeFile(fname);
  } finally {
    indent += indentSize;
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_jscode(arr) {
  assertArgs(arr, 2, "e0");
  noSemiColon = true;
  arr[1].replaceRight(/"/g, "");
  return arr[1];
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_macro(arr) {
  assertArgs(arr, 4, "e0");
  assertNode(arr[1]);
  assertForm(arr[2]);
  MACROS_MAP[arr[1].name] = {args: arr[2],
                             code: arr[3]};
  return "";
}

//////////////////////////////////////////////////////////////////////////////
//
function sf_not(arr) {
  assertArgs(arr, 2, "e0");
  evalSexp(arr);
  return "(!" + arr[1] + ")";
}

//////////////////////////////////////////////////////////////////////////////
//
function dbg(obj, hint) {
  if (isarray(obj)) {
    hint= hint || "block";
    console.log("<"+hint+">");
    for (var i=0; i < obj.length; ++i) {
      dbg(obj[i]);
    }
    console.log("</"+hint+">");
  } else if (isnode(obj)) {
    console.log("<node>");
    console.log(obj);
    dbg(obj.children,"subs");
    console.log("</node>");
  } else {
    console.log(obj);
  }
}

//////////////////////////////////////////////////////////////////////////////
//
function dbgAST(codeStr, fname) {
  let tree= toAST(codeStr, fname);
  dbg(tree, "tree");
}

//////////////////////////////////////////////////////////////////////////////
//
function compileCode(codeStr, fname, withSrcMap, a_include_dirs) {

  if (a_include_dirs) { include_dirs = a_include_dirs; }
  indent = -indentSize;

  let outNode = evalAST(toAST(codeStr, fname));
  outNode.prepend(banner);

  if (withSrcMap) {
    let outFile = path.basename(fname, ".ls") + ".js",
        srcMap = outFile + ".map",
        output = outNode.toStringWithSourceMap( { file: outFile });

    fs.writeFileSync(srcMap, output.map);
    return output.code +
           "\n//# sourceMappingURL=" +
           path.relative(path.dirname(fname), srcMap);
  } else {
    return outNode.toString();
  }
}

//////////////////////////////////////////////////////////////////////////////
//
exports.transpileWithSrcMap=function(code,file,incDirs) {
  return compileCode(code,file,true,incDirs);
};
exports.transpile=function(code,file,incDirs) {
  return compileCode(code,file,false,incDirs);
};
exports.version = version;
exports.dbgAST=dbgAST;
exports.parseWithSourceMap = function(codeStr, fname) {
  let outNode = evalAST(toAST(codeStr, fname));
  outNode.prepend(banner);
  return outNode.toStringWithSourceMap();
};

//////////////////////////////////////////////////////////////////////////////
//EOF



// Generated by LispyScript v1.5.0
require("./require");
let fs = require("fs"),
  path = require("path"),
  ls = require("./ls"),
  repl = require("./repl"),
  watch = require("watch"),
  isValidFlag = /-h\b|-r\b|-v\b|-b\b|-s\b|-t\b/,
  error = function (err) {
    console.error(err.message);
    return process.exit(1);
  };
let opt = ((((require('node-getopt')).create([['h', 'help', 'display this help'],
    ['v', 'version', 'show version'],
    ['r', 'run', 'run .ls files directly'],
    ['w', 'watch', 'watch and compile changed files beneath current directory'],
    ['b', 'browser-bundle', 'create browser-bundle.js in the same directory'],
    ['m', 'map', 'generate source map files'],
    ['t', 'tree', 'show AST tree'],
    ['i', 'include-dir=ARG+', 'add directory to include search path']])).setHelp(("lispy [OPTION] [<infile>] [<outfile>]\n\n" + "<outfile> will default to <infile> with '.js' extension\n\n" + "Also compile stdin to stdout\n" + "eg. $ echo '(console.log \"hello\")' | lispy\n\n" + "[[OPTIONS]]\n\n"))).bindHelp()).parseSystem();
(function (___monad) {
  let mBind = ___monad.mBind,
    mResult = ___monad.mResult,
    mZero = ___monad.mZero,
    mPlus = ___monad.mPlus;
  let ____mResult = function (___arg) {
    return (((typeof(___arg) === "undefined") && (!(typeof(mZero) === "undefined"))) ?
      mZero :
      mResult(___arg));
  };
  return mBind((((0 === opt.argv.length) && (0 === (Object.keys(opt.options)).length)) ?
    (function () {
      let output = process.stdout;
      let input = process.stdin;
      input.resume();
      input.setEncoding("utf8");
      let source = "";
      input.on("data",function (chunck) {
        source = (source + chunck.toString());
      });
      input.on("end",function () {
        return (function() {
        try {
          return output.write(ls.transpile(source,process.cwd));

        } catch (e) {
        return (error)(e);
        }
        })();
      });
      input.on("error",error);
      output.on("error",error);
      setTimeout(function () {
        return ((0 === input.bytesRead) ?
          (function () {
            input.removeAllListeners("data");
            return repl.runrepl();
          })() :
          undefined);
      },20);
      return null;
    })() :
    undefined),function (noargs) {
    return mBind(((true === opt.options['version']) ?
      (function () {
        console.log(("Version " + ls.version));
        return null;
      })() :
      ((true === opt.options['browser-bundle']) ?
        (function () {
          let bundle = require.resolve("lispyscript/lib/browser-bundle.js");
          (fs.createReadStream(bundle)).pipe(fs.createWriteStream("browser-bundle.js"));
          return null;
        })() :
        ((true === opt.options['run']) ?
          (function () {
            let infile = (opt.argv[0] ?
              (((opt.argv[0].indexOf('.ls') === -1) && (opt.argv[0].indexOf('.js') === -1)) ?
                error(new Error("Error: Input file must have extension '.ls' or '.js'")) :
                opt.argv[0]) :
              error(new Error("Error: No Input file given")));
            require(infile);
            return null;
          })() :
          ((true === opt.options['watch']) ?
            (function () {
              let cwd = process.cwd();
              console.log('Watching',cwd,'for .ls file changes...');
              watch.watchTree(cwd,{
                filter: function (f,stat) {
                  return (stat.isDirectory() || (f.indexOf('.ls') !== -1));
                },
                ignoreDotFiles: true,
                ignoreDirectoryPattern: /node_modules/
              },function (f,curr,prev) {
                return ((curr && (curr.nlink !== 0)) ?
                  (require("child_process")).spawn("lispy",[f.substring(cwd.length+1)],{stdio: "inherit"}) :
                  (((Object.prototype.toString.call(f) === "[object Object]") && (prev === null) && (curr === null)) ?
                    (function (o,f,s) {
                      let _k = Object.keys(o);
                      return (_k).forEach(function (elem) {
                        return f.call(s,o[elem],elem,o);
                      });
                    })(f,function (stat,initialf) {
                      return ((!(initialf === cwd)) ?
                        (function () {
                          return (function () {
                            return (require("child_process")).spawn("lispy",[initialf.substring(cwd.length+1)],{stdio: "inherit"});
                          })();
                        })() :
                        undefined);
                    }) :
                    undefined));
              });
              return null;
            })() :
            (true ?
              true :
              undefined))))),function (compile) {
      return mBind((opt.argv[0] ?
        opt.argv[0] :
        error(new Error("Error: No Input file given"))),function (infile) {
        return mBind((function () {
          let outfile = opt.argv[1];
          return (function () {
            ((!outfile) ?
              (function () {
                return (function () {
                  outfile = infile.replace(/\.ls$/,".js");
                  return ((outfile === infile) ?
                    error(new Error("Error: Input file must have extension '.ls'")) :
                    undefined);
                })();
              })() :
              undefined);
            return outfile;
          })();
        })(),function (outfile) {
          return (function () {
            return ____mResult((function() {
            try {
              let wantMap = (true === opt.options["map"]);
              let dbgAST = (true === opt.options["tree"]);
              let dirs = opt.options["include-dir"];
              ((!dbgAST) ?
                console.log(["lispy v",ls.version,":  compiling: ",infile," -> ",outfile].join('')) :
                undefined);
              let content = fs.readFileSync(infile,"utf8");
              return (dbgAST ?
                ls.dbgAST(content,infile,dirs) :
                fs.writeFileSync(outfile,(wantMap ?
                  ls.transpileWithSrcMap(content,infile,dirs) :
                  ls.transpile(content,infile,dirs)),"utf8"));

            } catch (e) {
            return (function (err) {
              error(err);
              return null;
            })(e);
            }
            })());
          })();
        });
      });
    });
  });
})({
  mBind: function (mv,mf) {
    return ((mv === null) ?
      null :
      mf(mv));
  },
  mResult: function (v) {
    return v;
  },
  mZero: null
});
